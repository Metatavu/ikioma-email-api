/**
* Payment service API
* Payment processing API  Note: The API is currently under development. Some endpoints do not yet have all the features described here, and the responses of some do not match the description here. 
*
* The version of the OpenAPI document: 2.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package fi.metatavu.ikioma.email.payment.api.spec

import fi.metatavu.ikioma.email.payment.spec.model.AddCardFormRequest
import fi.metatavu.ikioma.email.payment.spec.model.Error
import fi.metatavu.ikioma.email.payment.spec.model.TokenCITPaymentResponse
import fi.metatavu.ikioma.email.payment.spec.model.TokenMITPaymentResponse
import fi.metatavu.ikioma.email.payment.spec.model.TokenPaymentRequest
import fi.metatavu.ikioma.email.payment.spec.model.TokenizationRequestResponse

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class TokenPaymentsApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "https://api.checkout.fi")
        }
    }

    /**
    * Request a redirect to card addition form
    * Request a redirect to card addition form. This will redirect user to the card addition form, then back to Checkout servers, and finally to merchant&#39;s redirect url. 
    * @param addCardFormRequest Add card payload 
    * @return void
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addCardForm(addCardFormRequest: AddCardFormRequest) : Unit {
        val localVariableConfig = addCardFormRequestConfig(addCardFormRequest = addCardFormRequest)

        val localVarResponse = request<Any?>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation addCardForm
    *
    * @param addCardFormRequest Add card payload 
    * @return RequestConfig
    */
    fun addCardFormRequestConfig(addCardFormRequest: AddCardFormRequest) : RequestConfig {
        val localVariableBody: kotlin.Any? = addCardFormRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/tokenization/addcard-form",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Request a card token for given tokenization id
    * Use checkout-tokenization-id received from /tokenization/addcard-form redirect to request a token which can be used for payments. 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return TokenizationRequestResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestTokenForTokenizationId(checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : TokenizationRequestResponse {
        val localVariableConfig = requestTokenForTokenizationIdRequestConfig(checkoutAccount = checkoutAccount, checkoutAlgorithm = checkoutAlgorithm, checkoutMethod = checkoutMethod, checkoutTimestamp = checkoutTimestamp, checkoutNonce = checkoutNonce, signature = signature)

        val localVarResponse = request<TokenizationRequestResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenizationRequestResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation requestTokenForTokenizationId
    *
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return RequestConfig
    */
    fun requestTokenForTokenizationIdRequestConfig(checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        checkoutAccount?.apply { localVariableHeaders["checkout-account"] = this.toString() }
        checkoutAlgorithm?.apply { localVariableHeaders["checkout-algorithm"] = this.toString() }
        checkoutMethod?.apply { localVariableHeaders["checkout-method"] = this.toString() }
        checkoutTimestamp?.apply { localVariableHeaders["checkout-timestamp"] = this.toString() }
        checkoutNonce?.apply { localVariableHeaders["checkout-nonce"] = this.toString() }
        signature?.apply { localVariableHeaders["signature"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/tokenization/{checkout-tokenization-id}",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Request customer initiated transaction authorization hold on token
    * Request customer initiated transaction authorization hold on token. CIT authorization holds can sometimes require further 3DS authentication step-up. See detailed documentation at https://checkoutfinland.github.io/psp-api/#/?id&#x3D;customer-initiated-transactions-cit 
    * @param tokenPaymentRequest CIT authorization hold payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return TokenMITPaymentResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokenCitAuthorizationHold(tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : TokenMITPaymentResponse {
        val localVariableConfig = tokenCitAuthorizationHoldRequestConfig(tokenPaymentRequest = tokenPaymentRequest, checkoutAccount = checkoutAccount, checkoutAlgorithm = checkoutAlgorithm, checkoutMethod = checkoutMethod, checkoutTimestamp = checkoutTimestamp, checkoutNonce = checkoutNonce, signature = signature)

        val localVarResponse = request<TokenMITPaymentResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenMITPaymentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation tokenCitAuthorizationHold
    *
    * @param tokenPaymentRequest CIT authorization hold payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return RequestConfig
    */
    fun tokenCitAuthorizationHoldRequestConfig(tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = tokenPaymentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        checkoutAccount?.apply { localVariableHeaders["checkout-account"] = this.toString() }
        checkoutAlgorithm?.apply { localVariableHeaders["checkout-algorithm"] = this.toString() }
        checkoutMethod?.apply { localVariableHeaders["checkout-method"] = this.toString() }
        checkoutTimestamp?.apply { localVariableHeaders["checkout-timestamp"] = this.toString() }
        checkoutNonce?.apply { localVariableHeaders["checkout-nonce"] = this.toString() }
        signature?.apply { localVariableHeaders["signature"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/payments/token/cit/authorization-hold",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Request customer initiated transaction charge on token
    * Request customer initiated transaction charge on token. CIT charges can sometimes require further 3DS authentication step-up. See detailed documentation at https://checkoutfinland.github.io/psp-api/#/?id&#x3D;customer-initiated-transactions-cit 
    * @param tokenPaymentRequest CIT Charge payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return TokenMITPaymentResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokenCitCharge(tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : TokenMITPaymentResponse {
        val localVariableConfig = tokenCitChargeRequestConfig(tokenPaymentRequest = tokenPaymentRequest, checkoutAccount = checkoutAccount, checkoutAlgorithm = checkoutAlgorithm, checkoutMethod = checkoutMethod, checkoutTimestamp = checkoutTimestamp, checkoutNonce = checkoutNonce, signature = signature)

        val localVarResponse = request<TokenMITPaymentResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenMITPaymentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation tokenCitCharge
    *
    * @param tokenPaymentRequest CIT Charge payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return RequestConfig
    */
    fun tokenCitChargeRequestConfig(tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = tokenPaymentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        checkoutAccount?.apply { localVariableHeaders["checkout-account"] = this.toString() }
        checkoutAlgorithm?.apply { localVariableHeaders["checkout-algorithm"] = this.toString() }
        checkoutMethod?.apply { localVariableHeaders["checkout-method"] = this.toString() }
        checkoutTimestamp?.apply { localVariableHeaders["checkout-timestamp"] = this.toString() }
        checkoutNonce?.apply { localVariableHeaders["checkout-nonce"] = this.toString() }
        signature?.apply { localVariableHeaders["signature"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/payments/token/cit/charge",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Request committing (charging) of previously created authorization hold on token
    * Request committing of previously created authorization hold. The final amount committed can either equal or be less than the authorization hold. The committed amount may not exceed the authorization hold. The final items may differ from the ones used when creating the authorization hold. 
    * @param transactionId Transaction ID of payment to activate invoice 
    * @param tokenPaymentRequest CIT commit payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return TokenMITPaymentResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokenCommit(transactionId: java.util.UUID, tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : TokenMITPaymentResponse {
        val localVariableConfig = tokenCommitRequestConfig(transactionId = transactionId, tokenPaymentRequest = tokenPaymentRequest, checkoutAccount = checkoutAccount, checkoutAlgorithm = checkoutAlgorithm, checkoutMethod = checkoutMethod, checkoutTimestamp = checkoutTimestamp, checkoutNonce = checkoutNonce, signature = signature)

        val localVarResponse = request<TokenMITPaymentResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenMITPaymentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation tokenCommit
    *
    * @param transactionId Transaction ID of payment to activate invoice 
    * @param tokenPaymentRequest CIT commit payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return RequestConfig
    */
    fun tokenCommitRequestConfig(transactionId: java.util.UUID, tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = tokenPaymentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        checkoutAccount?.apply { localVariableHeaders["checkout-account"] = this.toString() }
        checkoutAlgorithm?.apply { localVariableHeaders["checkout-algorithm"] = this.toString() }
        checkoutMethod?.apply { localVariableHeaders["checkout-method"] = this.toString() }
        checkoutTimestamp?.apply { localVariableHeaders["checkout-timestamp"] = this.toString() }
        checkoutNonce?.apply { localVariableHeaders["checkout-nonce"] = this.toString() }
        signature?.apply { localVariableHeaders["signature"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/payments/{transactionId}/token/commit".replace("{"+"transactionId"+"}", "$transactionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Request merchant initiated transaction authorization hold on token
    * Request merchant initiated transaction authorization hold on token. This method should be used when creating an authorization hold on the customer&#39;s card in a context, where the customer is not actively participating in the transaction. 
    * @param tokenPaymentRequest MIT Charge payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return TokenMITPaymentResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokenMitAuthorizationHold(tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : TokenMITPaymentResponse {
        val localVariableConfig = tokenMitAuthorizationHoldRequestConfig(tokenPaymentRequest = tokenPaymentRequest, checkoutAccount = checkoutAccount, checkoutAlgorithm = checkoutAlgorithm, checkoutMethod = checkoutMethod, checkoutTimestamp = checkoutTimestamp, checkoutNonce = checkoutNonce, signature = signature)

        val localVarResponse = request<TokenMITPaymentResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenMITPaymentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation tokenMitAuthorizationHold
    *
    * @param tokenPaymentRequest MIT Charge payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return RequestConfig
    */
    fun tokenMitAuthorizationHoldRequestConfig(tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = tokenPaymentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        checkoutAccount?.apply { localVariableHeaders["checkout-account"] = this.toString() }
        checkoutAlgorithm?.apply { localVariableHeaders["checkout-algorithm"] = this.toString() }
        checkoutMethod?.apply { localVariableHeaders["checkout-method"] = this.toString() }
        checkoutTimestamp?.apply { localVariableHeaders["checkout-timestamp"] = this.toString() }
        checkoutNonce?.apply { localVariableHeaders["checkout-nonce"] = this.toString() }
        signature?.apply { localVariableHeaders["signature"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/payments/token/mit/authorization-hold",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Request merchant initiated transaction charge on token
    * Request merchant initiated transaction charge on token. This method should be used when charging the customer&#39;s card in a context, where the customer is not actively participating in the transaction. 
    * @param tokenPaymentRequest MIT Charge payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return TokenMITPaymentResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokenMitCharge(tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : TokenMITPaymentResponse {
        val localVariableConfig = tokenMitChargeRequestConfig(tokenPaymentRequest = tokenPaymentRequest, checkoutAccount = checkoutAccount, checkoutAlgorithm = checkoutAlgorithm, checkoutMethod = checkoutMethod, checkoutTimestamp = checkoutTimestamp, checkoutNonce = checkoutNonce, signature = signature)

        val localVarResponse = request<TokenMITPaymentResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenMITPaymentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation tokenMitCharge
    *
    * @param tokenPaymentRequest MIT Charge payload 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return RequestConfig
    */
    fun tokenMitChargeRequestConfig(tokenPaymentRequest: TokenPaymentRequest, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = tokenPaymentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        checkoutAccount?.apply { localVariableHeaders["checkout-account"] = this.toString() }
        checkoutAlgorithm?.apply { localVariableHeaders["checkout-algorithm"] = this.toString() }
        checkoutMethod?.apply { localVariableHeaders["checkout-method"] = this.toString() }
        checkoutTimestamp?.apply { localVariableHeaders["checkout-timestamp"] = this.toString() }
        checkoutNonce?.apply { localVariableHeaders["checkout-nonce"] = this.toString() }
        signature?.apply { localVariableHeaders["signature"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/payments/token/mit/charge",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Revert (removal) of previously created authorization hold on token
    * Request committing of previously created authorization hold. A successful revert will remove the authorization hold from the payer&#39;s bank account. 
    * @param transactionId Transaction ID of payment to activate invoice 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return TokenMITPaymentResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tokenRevert(transactionId: java.util.UUID, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : TokenMITPaymentResponse {
        val localVariableConfig = tokenRevertRequestConfig(transactionId = transactionId, checkoutAccount = checkoutAccount, checkoutAlgorithm = checkoutAlgorithm, checkoutMethod = checkoutMethod, checkoutTimestamp = checkoutTimestamp, checkoutNonce = checkoutNonce, signature = signature)

        val localVarResponse = request<TokenMITPaymentResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TokenMITPaymentResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation tokenRevert
    *
    * @param transactionId Transaction ID of payment to activate invoice 
    * @param checkoutAccount Merchant ID (optional)
    * @param checkoutAlgorithm HMAC algorithm (optional)
    * @param checkoutMethod HTTP method of the request (optional)
    * @param checkoutTimestamp Current timestamp in ISO 8601 format (optional)
    * @param checkoutNonce Unique random identifier (optional)
    * @param signature HMAC signature calculated over the request headers and payload (optional)
    * @return RequestConfig
    */
    fun tokenRevertRequestConfig(transactionId: java.util.UUID, checkoutAccount: kotlin.Int?, checkoutAlgorithm: kotlin.String?, checkoutMethod: kotlin.String?, checkoutTimestamp: java.time.OffsetDateTime?, checkoutNonce: kotlin.String?, signature: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        checkoutAccount?.apply { localVariableHeaders["checkout-account"] = this.toString() }
        checkoutAlgorithm?.apply { localVariableHeaders["checkout-algorithm"] = this.toString() }
        checkoutMethod?.apply { localVariableHeaders["checkout-method"] = this.toString() }
        checkoutTimestamp?.apply { localVariableHeaders["checkout-timestamp"] = this.toString() }
        checkoutNonce?.apply { localVariableHeaders["checkout-nonce"] = this.toString() }
        signature?.apply { localVariableHeaders["signature"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/payments/{transactionId}/token/revert".replace("{"+"transactionId"+"}", "$transactionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

}
